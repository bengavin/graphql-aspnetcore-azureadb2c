# Securing ASP.NET Core GraphQL API with Azure Active Directory B2C
#
# Build Script
# 
# Basic Flow
# - Build API Package
# - Test Environment
#   - Ensure Environment State
#   - Deploy API to environment
# - Stage Environment
#   - Ensure Environment State
#   - Deploy API to environment
# ... production ... eventually ...

trigger:
- main

pool:
  vmImage: ubuntu-latest

# NOTE: This is a workaround for service connections not supporting variable replacement
#       at runtime (see: https://developercommunity.visualstudio.com/t/using-a-variable-for-the-service-connection-result/676259)
parameters:
- name: TestEnvironmentServiceConnection
  default: $(Deployment.Subscription.Test)
  type: string
- name: StageEnvironmentServiceConnection
  default: $(Deployment.Subscription.Stage)
  type: string

stages:
- stage: BuildApiStage
  displayName: Build API
  jobs:
    - job: BuildApiJob
      displayName: Build Api
      steps:
        - task: DotNetCoreCLI@2
          displayName: dotnet build
          inputs:
            command: 'build'
            projects: 'api/StarWars.API.csproj'

        - task: DotNetCoreCLI@2
          displayName: dotnet publish
          inputs:
            command: 'publish'
            projects: 'api/StarWars.API.csproj'
            arguments: '--output $(Build.ArtifactStagingDirectory)'
            zipAfterPublish: true

        - task: PublishPipelineArtifact@1
          displayName: Publish API package to pipeline
          inputs:
            targetPath: '$(Build.ArtifactStagingDirectory)/api.zip'
            artifact: 'ApiPackage'
            publishLocation: 'pipeline'

- stage: TestEnvironmentStage
  displayName: Test Environment
  dependsOn: BuildApiStage
  variables: 
    - group: securegqldemo - Test
  jobs:
    - job: DeployTestEnvironmentJob
      displayName: Deploy test environment
      steps:
      - task: AzureCLI@2
        displayName: Deploy Bicep template
        inputs:
          azureSubscription: ${{ parameters.TestEnvironmentServiceConnection }}
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          workingDirectory: 'infrastructure'
          addSpnToEnvironment: true
          inlineScript: |
            echo "Ensure secret list permissions"
            vaultName=kv-$(Deployment.Environment)-$(Deployment.Application)
            az keyvault set-policy --name $vaultName --secret-permissions list --spn $servicePrincipalId

            echo "Retrieving Existing KeyVault Secret Name(s)"
            secretNames=`az keyvault secret list --vault-name $vaultName --query '[].name' --output json`

            echo "Deploying Bicep Template..."
            outputs=`az deployment sub create --name playbook-$(Deployment.Application)-$(Deployment.Environment) --location $(Deployment.Metadata.Location) --template-file playbook.bicep --parameters vars/playbook.parameters.json vars/playbook.parameters.$(Deployment.Environment).json existingKeyVaultSecrets=$secretNames`

            echo "Capturing outputs..."
            echo $outputs | jq -c '.properties.outputs | to_entries[] | [.key, .value.value]' | 
              while IFS=$"\n" read -r c; do
                outputname=$(echo "$c" | jq -r '.[0]')
                outputvalue=$(echo "$c" | jq -r '.[1]')
                echo "##vso[task.setvariable variable=Deployment.Output.$outputname]$outputvalue"
              done

      - task: DownloadPipelineArtifact@2
        displayName: Download API Package
        inputs:
          buildType: 'current'
          artifactName: ApiPackage
          targetPath: '$(System.ArtifactsDirectory)'

      - task: FileTransform@1      
        displayName: Update settings file(s)
        inputs:
          folderPath: '$(System.ArtifactsDirectory)/api.zip'
          fileType: 'json'
          targetFiles: 'appsettings.json'

      - task: AzureRmWebAppDeployment@4
        displayName: Publish API Package - Test
        inputs:
          ConnectionType: 'AzureRM'
          azureSubscription: ${{ parameters.TestEnvironmentServiceConnection }}
          appType: 'webAppLinux'
          WebAppName: '$(Deployment.Output.apiAppName)'
          packageForLinux: '$(System.ArtifactsDirectory)/api.zip'

- stage: StageEnvironmentStage
  displayName: Stage Environment
  dependsOn: BuildApiStage
  variables: 
    - group: securegqldemo - Stage
  jobs:
    - job: DeployStageEnvironmentJob
      displayName: Deploy stage environment
      steps:
      - task: AzureCLI@2
        displayName: Deploy Bicep template
        inputs:
          azureSubscription: ${{ parameters.StageEnvironmentServiceConnection }}
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          workingDirectory: 'infrastructure'
          inlineScript: |
            echo "Deploying Bicep Template..."
            outputs=`az deployment sub create --name playbook-$(Deployment.Application)-$(Deployment.Environment) --location $(Deployment.Metadata.Location) --template-file playbook.bicep --parameters vars/playbook.parameters.json vars/playbook.parameters.$(Deployment.Environment).json`

            echo "Capturing outputs..."
            echo $outputs | jq -c '.properties.outputs | to_entries[] | [.key, .value.value]' | 
              while IFS=$"\n" read -r c; do
                outputname=$(echo "$c" | jq -r '.[0]')
                outputvalue=$(echo "$c" | jq -r '.[1]')
                echo "##vso[task.setvariable variable=Deployment.Output.$outputname]$outputvalue"
              done

      - task: DownloadPipelineArtifact@2
        displayName: Download API Package
        inputs:
          buildType: 'current'
          artifactName: ApiPackage
          targetPath: '$(System.ArtifactsDirectory)'

      - task: FileTransform@1      
        displayName: Update settings file(s)
        inputs:
          folderPath: '$(System.ArtifactsDirectory)/api.zip'
          fileType: 'json'
          targetFiles: 'appsettings.json'

      - task: AzureRmWebAppDeployment@4
        displayName: Publish API Package - Stage
        inputs:
          ConnectionType: 'AzureRM'
          azureSubscription: ${{ parameters.StageEnvironmentServiceConnection }}
          appType: 'webAppLinux'
          WebAppName: '$(Deployment.Output.apiAppName)'
          packageForLinux: '$(System.ArtifactsDirectory)/api.zip'
